# Stack1

- ## 스택
  
  - 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
  
  - 스택에 저장된 자료는 선형 구조를 갖는다.
  
  - 선형 구조 : 자료간의 관계가 1대1
  
  - 비선형 구조 : 자료간의 관계가 1대 N >>> ex) 트리
  
  - 마지막에 삽입한 자료를 가장 먼저 꺼낸다.
  
  - 후입선출

- ## 스택을 프로그램에서 구현하기 위해서 필요한 자료구조와 연산
  
  - ### 자료구조 : 자료를 선형으로 저장할 저장소
    
    - 배열을 사용할 수 있다.
    
    - 저장소 자체를 스택이라 부르기도 한다
    
    - 스택에서 마지막 삽입된 원소의 위치를 top 이라 부른다.
  
  - ### 연산
    
    - 삽입 : 저장소에 자료를 저장 > push라고 부른다
    
    - 삭제 : 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순 > pop라고 부른다 자료를 꺼내도 저장소에 자료는 남아있다.
    
    - 따로 지우는 동작은 없고 만약 자료를 꺼낸 후 다시 자료를 넣을때면 원래 자료가 있던 자리에 덮어 씌우는 형식으로 자료가 들어간다.
    
    ![캡처.PNG](algorithm_05(stack)_assets/0dda280ce6df00ae682e0a2ba8f9e23336d59141.PNG)
    
    자료에 A, B가 있는 상태에서 C를 넣었다가 꺼낸 후 D를 넣는 과정
    
    C 가 있던 자리에 D를 덮어씌움
    
    이 과정이 삭제와 동일하기 때문에 삭제라하고 보통 pop라고 함
    
    - isEmpty : 스택이 공백인지 아닌지를 확인하는 연산
    
    - peek : 스택의 top에 있는 원소(item)을 반환하는 연산

```python
stack = [0] * 3
top = -1

top += 1    # push(10)
stack[top] = 10

top += 1    # push(20)
stack[top] = 20

top += 1    # push(30)
stack[top] = 30


###################pop####################
if top > -1:
    top -= 1
    print(stack[top+1])    # 30

if top > -1:
    top -= 1
    print(stack[top+1])    # 20

if top > -1:
    top -= 1
    print(stack[top+1])    # 10


# 이렇게 하는게 pop을 해서 호출한다고 삭제가 아니기 때문에 한번더 호출하면 다시 처음값이
# 나오는 경우가 있으므로 조건을 지정해서 처음값이 나오지 않게 해주는 
```

- 스택 구현 고려 사항 >> 스택 만들라면 일단 리스트 만들면 된다하심
  
  - 1차원 배열을 사요아여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이 있다.
  
  - 이를 해결하기 위해 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다
    
    - 구현이 복잡하지만 메모리를 효율적으로 사용

## 스택의 응용1 : 괄호검사

1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.

2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.

3. 괄호 사이에는 포함 관계만 존재한다.

## 스택의 응용 2 : function call

- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리

- 후입선출구조 : > 가장마지막 호출 함수가 가장 먼저 실행을 완료하고 복귀

- 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입

- 함수 실행 종료시 스택의 top원소를 삭제 하면서 프레임에 저장된 복귀주소 확인 후 복귀

- 반복하여 전체 프로그램 종료 >> 시스템 스택은 공백 스택

## 재귀호출(하향식 DP 라고 부르기도 한다ㅣ.)

- 자기 자신을 호출하여 순환 수행되는 것

- 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성 가능하다 >>> ex) factorial

- ```python
  # factorial
  def fact(N):
      if N == 1:
          return 1
      else:
          return N * fact(N-1)
  ```

- ```python
  # fibo
  def fibo(N):
      if N < 2:
          return N
      else:
          return fibo(N-1) + fibo(N-2)
  ```



# Memoization

- 동적계획법의 핵심이 되는 기술

- 프로그램 동작시 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않게 하여 실행속도를 빠르게 하는 기술

- 큰 문제를 작은문제로 쪼개고 다시 쪼갠걸 쪼개서 반복해서 제일 작은 값을 기록

- 탑다운 방식(위에서 아래로)이라고도 한다



# DP(동적계획법)

- 작은 부분 문제들을 모두 해결한 후 그 해들을 이용하여 보다 큰 크기의 문제들을 해결하는 방법

- 타뷸레이션?
  
  바텀업이라고 하는데
  
  Memoization은 5를 해결하기위해서 4를 4를 해결 3을 >> 2 >> 1>> 이런식으로 가는데
  
  타뷸레이션은 5라는 작업을 할때 애초에 작았었던 값부터 시작
  
  0과 1을 디폴트로 잡고 2부터 5까지의 문제를 순서대로 해결해 나가는데 이전에 처리해 나갔던 방식을 활용하는것



# DFS(깊이우선탐색), BFS(너비우선탐색)

- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함

- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면 가장 마지막에 만났던 갈림길이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 모든 정점을 방문하는 순회방법



- 방문안한 정점 w가 있으면 정점 v를 스택에 넣고 정점 w 방문

- 그리고 w를 v로 하여 다시 반복

- 방문하지 않은 정점이 없으면 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 반복

- 스택이 공백이 될때까지 반복한다.

![](algorithm_05(stack)_assets/2023-02-14-10-54-39-image.png)

![](algorithm_05(stack)_assets/2023-02-14-10-57-40-image.png)

지금 1이 찍힌 위치를 보면 서로간의 관계를 가지는 것들은 모두 1이 들어가 있다

가령 1이 2와 3을 관계를 가지고 있을때

2와 3을 보면 둘다 1과 관계를 가지고 있다

이렇게 찍힌게 인접행렬 이라한다.

![](algorithm_05(stack)_assets/2023-02-14-10-59-16-image.png)

`       adjL[v2].append(v1)`

이렇게 풀어쓰면

![](algorithm_05(stack)_assets/2023-02-14-11-00-24-image.png)

요런식으로 저장된다

이 코드가 DFS의 저장방식

위에서 표현한 정점의 정확한 명칭 : 노드

노드 사이의 길이 : 간선
