# Stack1

- 스택
  
  - 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
  
  - 스택에 저장된 자료는 선형 구조를 갖는다.
  
  - 선형 구조 : 자료간의 관계가 1대1
  
  - 비선형 구조 : 자료간의 관계가 1대 N >>> ex) 트리
  
  - 마지막에 삽입한 자료를 가장 먼저 꺼낸다.
  
  - 후입선출

- 스택을 프로그램에서 구현하기 위해서 필요한 자료구조와 연산
  
  - 자료구조 : 자료를 선형으로 저장할 저장소
    
    - 배열을 사용할 수 있다.
    
    - 저장소 자체를 스택이라 부르기도 한다
    
    - 스택에서 마지막 삽입된 원소의 위치를 top 이라 부른다.
  
  - 연산
    
    - 삽입 : 저장소에 자료를 저장 > push라고 부른다
    
    - 삭제 : 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순 > pop라고 부른다 자료를 꺼내도 저장소에 자료는 남아있다.
    
    - 따로 지우는 동작은 없고 만약 자료를 꺼낸 후 다시 자료를 넣을때면 원래 자료가 있던 자리에 덮어 씌우는 형식으로 자료가 들어간다.
    
    ![캡처.PNG](algorithm_05(stack)_assets/0dda280ce6df00ae682e0a2ba8f9e23336d59141.PNG)
    
    자료에 A, B가 있는 상태에서 C를 넣었다가 꺼낸 후 D를 넣는 과정
    
    C 가 있던 자리에 D를 덮어씌움
    
    이 과정이 삭제와 동일하기 때문에 삭제라하고 보통 pop라고 함
    
    - isEmpty : 스택이 공백인지 아닌지를 확인하는 연산
    
    - peek : 스택의 top에 있는 원소(item)을 반환하는 연산

```python
stack = [0] * 3
top = -1

top += 1    # push(10)
stack[top] = 10

top += 1    # push(20)
stack[top] = 20

top += 1    # push(30)
stack[top] = 30


###################pop####################
if top > -1:
    top -= 1
    print(stack[top+1])    # 30

if top > -1:
    top -= 1
    print(stack[top+1])    # 20

if top > -1:
    top -= 1
    print(stack[top+1])    # 10


# 이렇게 하는게 pop을 해서 호출한다고 삭제가 아니기 때문에 한번더 호출하면 다시 처음값이
# 나오는 경우가 있으므로 조건을 지정해서 처음값이 나오지 않게 해주는 
```

- 스택 구현 고려 사항 >> 스택 만들라면 일단 리스트 만들면 된다하심
  
  - 1차원 배열을 사요아여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이 있다.
  
  - 이를 해결하기 위해 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다
    
    - 구현이 복잡하지만 메모리를 효율적으로 사용

스택의 응용1 : 괄호검사

1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.

2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.

3. 괄호 사이에는 포함 관계만 존재한다.

스택의 응용 2 : function call

- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리

- 후입선출구조 : > 가장마지막 호출 함수가 가장 먼저 실행을 완료하고 복귀

- 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입

- 함수 실행 종료시 스택의 top원소를 삭제 하면서 프레임에 저장된 복귀주소 확인 후 복귀

- 반복하여 전체 프로그램 종료 >> 시스템 스택은 공백 스택

- Memoization

- DP

- DFS
