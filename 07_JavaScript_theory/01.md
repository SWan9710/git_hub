# JavaScript

> ## 웹 브라우저의 역할

- URL을 통해 웹을 탐색함

순수하게 JavaScript 문법들을 이용한 코딩을 바닐라 코딩이라 함

EcmaScript

- 표준화된 스크립트 프로그래밍 언어

- 자바스크립트를 표준화 하기위해 만들어짐

자바스크립트

- 세미콜론 써도 되고 안써도 되고

---

## 식별자

- 변수를 구분할 수 있는 변수명

- 식별자는 반드시 문자,달러,밑줄로 시작

- 대소문자 구분, 클래스명 이외에는 모두 소문자로 시작

- 예약어 사용 불가
  
  - 예약어 : for, if, function

- 카멜 케이스
  
  - 변수, 객체, 함수에 사용
  
  - 중간에 대문자 들어가는거 camelCase 이런식으로

![](01_assets/2023-04-18-09-40-01-image.png)

- 파스칼 케이스
  
  - 클래스, 생성자에 사용
  
  - 첫문자부터 대문자 PascalCase 이런식

![](01_assets/2023-04-18-09-40-10-image.png)

- 대문자 스네이크 케이스
  
  - 상수에 사용
  
  - 변경되지 않는 값 SNAKE_CASE

![](01_assets/2023-04-18-09-40-18-image.png)

---

## 변수 선언 키워드

1. let
   
   - 블록 스코프 지역 변수를 선언 동시에 값을 초기화
   
   ```javascript
   // ok
   let number = 10
   number = 20
   
   // X
    let number = 10
    let number = 20
   ```

2. const
   
   - 읽기 전용 상수를 선언 동시에 값을 초기화
   
   - let 과 동일하게 블록 스코프를 가진다.

```javascript
// X
let number = 10
number = 20 
// X
let number = 10
let number = 20
```

> [참고] 블록 스코프

- if, for, 함수 등의 중괄호{} 내부를 카리킴

- 블록 스코프를 가지는 변수는 외부에서 접근 불가
1. var
   
   - 재할당 & 재선언 가능
   
   - <mark>호이스팅 </mark>특성으로 예기치 못한 문제 발생 가능
   
   - 함수 스코프 가짐

> [참고] 함수 스코프

- 함수의 중괄호 내부

- 외부에서 접근 불가

> [참고] 호이스팅

- 변수를 선언 이전에 참조할 수 있는 현상

- var 로 선언된 변수는 선언 이전에 참조할 수 있으며, 이러한 현상을 호이스팅이라 함

- 변수 선언하기 전에 먼저 접근하면 var 로 선언하고 다시 밑에서 재선언, 재할당이 이루어져서 먼저 출력하면 undifined 반환함

- 이런거 때매 var 쓰면 안댐

![](01_assets/2023-04-18-14-58-38-image.png)

---

## 데이터타입

> - JavaScripy의 모든 값은 특정한 데이터 타입을 가진다.
> 
> - 원시타입 / 참조타입 으로 나뉨

> ### 원시타입

- Number
  
  > - 정수 또는 실수
  > 
  > - NaN 반환하는 경우
  >   
  >   - 숫자 X
  >   
  >   - 허수
  >   
  >   - 피연산자가 NaN
  >   
  >   - 정의불가
  >   
  >   - 문자열 포함 하며 덧셈이 아닌 계산식

- String
  
  > - 문자열
  > 
  > - 작은 따옴표, 큰 따옴표 
  > 
  > - 문자열 덧셈만 가능
  > 
  > - 따옴표 쓰면 줄바꿈 못하니 \n >> escpae sequence로 사용
  > 
  > - 백틱 (`) 써서 줄바꿈 가능한 문자열작성 가능 / 변수 삽입도 가능
  >   
  >   - 파이썬의 f 스트링 함수
  >   
  >   - ` ${} ` << 이거로 사용

- Empth Value
  
  > - null
  >   
  >   - 값이 없음을 의도적으로 표현
  > 
  > - undefined
  >   
  >   - 변수 선언 후 값을 할당하지 않으면 자동 할당됨

- Boolean
  
  > - true 와 false
  > 
  > - 조건문 또는 반복문에서 주로 사용
  > 
  > - boolean이 아닌 데이터 타입은 자동 형변환 규칙에 따라 true 또는 false로 변환됨

---

- ~~Symbol~~

> ### 참조 타입

- Object
  
  > - 이름과 값을 가진 속성들의 집합의 자료구조
  > 
  > - key
  >   
  >   - 문자열 타입만 가능
  >   
  >   - 띄어쓰기 등의 구분자가 있으면 따옴표로 묶어서 전달
  > 
  > - value
  >   
  >   - 모든 타입 가능
  > 
  > - 객체 요소 접근
  >   
  >   - 점(.) 또는 대괄호([])로 가능
  >   
  >   - key에 띄어쓰기 같은 구분자 있으면 대괄호만 가능
  
  ![](01_assets/2023-04-18-15-17-33-image.png)

- Array
  
  > - 여러 개의 값을 순서대로 저장하는 자료구조
  > 
  > - 키와 속성들을 담고 있는 참조 타입의 객체
  > 
  > - 순서 보장
  > 
  > - 대괄호로 생성, 0을 포함한 양의 정수 인덱스로 특정 값에 접근가능
  > 
  > - 배열의 길이 >> array.length
  
  ![](01_assets/2023-04-18-15-19-41-image.png)

- function(함수)
  
  > - function 키워드를 통해 생성되며, 호출 시 실행 될 코드 정의
  > 
  > - 참조 타입 중 하나로써 function 타입
  > 
  > - 함수 선언식
  > 
  > - 함수 표현식

> 함수 선언식

- 일반적인 프로그래밍 언어의 함수 정의 방식
  
  ```javascript
  function add(num1, num2){
      return num1 + num2
  }
  add(2, 7) // 9
  ```

> 함수 표현식

- 표현식 내에서 함수를 정의하는 방식

- 함수의 이름을 생략한 익명함수로 정의 가능

```javascript
const sub = function(num1, num2){
    return num1 - num2
}

sub(7, 2) // 5
```

- 표현식에서 함수 이름을 명시하는 것도 가능한데 호출에 사용되지 못하고 디버깅 용도로 사용됨

![](01_assets/2023-04-18-10-31-28-image.png)

> 자동형변환

| 데이터타입     | false      | true         |
|:---------:|:----------:|:------------:|
| undifined | 항상 false   | X            |
| null      | 항상 false   | X            |
| Number    | 0, -0, NaN | 나머지는 전부 true |
| String    | 빈 문자열      | 나머지 모든 경우    |
| Object    | X          | 항상 true      |

> 할당 연산자

- 오른쪽에 있는 피연산자의 평가 결과를 왼쪽 피연산자에 할당하는 연산자

- 다앙한 연산에 대한 단축 연산자 지원

---

> 비교 연산자

- 피연산자들 을 비교하고 결과값을 boolean으로 반환

- 알파벳끼리 비교할 경우 알파벳 순서상 후순위가 더 크다
  
  - 소문자가 대문자보다 더 크다

---

> 동등연산자(==)

- 두 피연산자가 같은 값으로 평가되는지 비교 후 boolean 값을 반환

- 비교할 때 암묵적 타입 변환 통해 타입을 일치시킨 후 같은 값인지 비교(자동현변환 발생)

- 두 피연산작 모두 객체일 경우 같은 객체를 바라보는지 판별

- 예상치 못한 결과가 나올 수 있으니 특별한 경우를 제외하고는 사용 X

---

> 일치연산자(===)

- 두피연산자의 값과 타입이 모두 같은 경우 true 반환

- 암묵적 타입 변환 발생 X

- 엄격한 비교 > 두 비교 대상의 타입과 값 모두 같은 지 비교하는 방식

---

> 논리 연산자

- AND == &&

- OR == ||

- NOT = !

---

단축 평가 지원

- and -> 전부다 true ==> true

- or -> 1개라도 true면 true

- > ex false && true => false
  > 
  > ex true || false => true
  
  or => 둘중 하나라도 true 면 true 반환하니까 앞자리에 true가 오면 그냥 앞자리 바로 반환하고 끝내버림
  
  and => 둘다 true 여야 true 반환하니 둘다 비교해 보는데 뒤에거가 true 가 오면 뒤에거를 반환해줌

---

> 삼항연산자

- true ? 1 : 2 // 1

- fasle ? 1 : 2 // 2
  
  가장 앞의 조건식이 참이면 : 앞의 값이 반환되며, 반대의 경위 뒤의 값이 반환
  
  ? 부분은 조건식이 들어가는 부분
  
  ![](01_assets/2023-04-18-10-49-35-image.png)

---

> 스프레드 연산자

- 배열이나 객체를 전개하여 각 요소를 개별적인 값으로 분리하는 연산자

- 얕은 복사를 위해서도 활용 가능

예를들어 리스트 안에 [3,4] 가 있고 이때 변수명이 const num 일 경우 표현식은

```javascript
const num = [3, 4]
// 여기서 other num 에 [1,2,5] 가 있는 경우 여기서 3 4 를 넣어서 1 2 3 4 5 를 만들려
const otherNum = [1,2, ...num, 5] // 이렇게 쓰면 됨
```

const copyNum = [...num] 하면 [3, 4] 보여줌

---

> 조건문

- if, else if, else
  
  - 조건은 소괄호
  
  - 실행 코드는 중괄호

```javascript
const name = 'manager'


if(name === 'admin') {
    console.log('관리자')
} else if(name === 'manager') {
    console.log('매니저')
}     
```

---

> 반복문

- for
  
  - 특정한 조건이 거짓으로 판별될 때 까지 반복
  
  - for ([초기문] [조건문] [증감문])
  
  - for (let i = 0; i < 6; i++)
    
    - i는 0부터 1씩 증가하느데 6이 되면 종료하는걸 이런식으로 표현함

- for ... in
  
  - 객체의 속성을 순회할 때 사용
  
  - 배열도 순회 가능하지만 인덱스 순으로 순회한다는 보장이 없으므로 권장X

- for ... of
  
  - 배열을 순회할 때 사용

in 과 of의 차이

```javascript
const arr = [3, 5, 7]

for (const i in arr) {
    console.log(i) // 0 1 2
}

for (const i of arr) {
    console.log(i) // 3 5 7
}
```

- in을 사용하면 배열의 이름 즉 배열의 인덱스 번호를 반환하는데
  
  of 를 사용하면 배열의 밸류값 배열안의 값을 들고옴

- 딕셔너리로 보면 for in은 key값을 들고오고
  
  for of 는 value 값을 들고옴
  
  ![](01_ssafy/2023-04-18-12-10-59-image.png)
  
  ![](01_ssafy/2023-04-18-12-11-08-image.png)
  
  > [참고] for 과 for ... in / for ... of
  
  - 그냥 for 문은 최초 정의한 i를 재할당 하면서 사용해서 const 쓰면 에러남
  
  - in / of 는 재할당이 아니라 해당 변수를 새로 정의해서 쓰는거라 const 써야함

![](01_ssafy/2023-04-18-12-13-40-image.png)
