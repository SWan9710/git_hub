# python_04

## 내장 함수

> - 파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형(type)이 내장되어 있음

- ### map(function, iterable)
  
  - map 함수는 결과를 담은 값을 리스트로 형변화 시켜서 실행해줘야 제대로 된 프린트 결과를 볼 수 있음

- ### filter(function, iterable)
  
  - True만 걸러주는 함수 function을 적용한 결과가 True인 애들만 모아서 반환해줌
  
  - filter 역시 출력할때 리스트 같은 형변환을 해서 출력해야함

- ### zip(*iterables)
  
  - 반복가능한 객체들이 들어가 zip으로 묶어줌
  
  - ![](C:\Users\SSAFY\AppData\Roaming\marktext\images\2023-01-19-09-25-29-image.png)
  
  - 객체들을 순서대로 1:1로 묶어줌

- ### lambda 함수 > 익명함수 라고도 한다.
  
  - 이름을 안짓는 함수
  
  - 함수를 정의해서 사용하는 것보다 간결하게 사용가능 하고
  
  - def를 사용 못하는 곳에서도 사용 가능하다.
  
  - 간편 조건문 외 조건문, 반복문, return문을 가질수 없음

- ### lambda 매게변수 : 매게변수를 이용한 리턴값
  
  - `(lambda x: x * x)` 형식으로 작성
  
  - `print((lambda x: x*x)(4)` > 매게변수값 4가 x에 들어감

- ### 재귀 함수
  
  - 자기 자신을 호출하는 함수
  
  - 무한한 호출을 목표로 하는것이 아닌 알고리즘 설계 및 구현에서 유용하게 활용
    
    - 알고리즘 중 재귀 함수로 로직을 표현하기 쉬운 경우가 있음(ex: 점화식)
    
    - 변수의 사용이 줄며, 코드의 가독성이 좋아짐
  
  - **<mark>1개 이상의 종료되는 상황이 존재하고, 수렴하도록 작성</mark>**

- ### 반복문과 재귀 함수 비교
  
  - 알고리즘 자체가 재귀적인 표현이 자연스러운 경우 재귀함수 사용
  
  - 재귀 호출은 변수사용을 줄여줌
  
  - 재귀 호출은 입력값이 커질수록 연산속도가 오래걸림

## 패킹/언패킹

> - 모든 시퀀스형(리스트, 튜플 등)은 패킹/언패킹 연산자*를 사용하여 객체의 패킹 또는 언패킹이 가능

- 패킹 > 묶는거

- 언패킹 > 푸는거

![](C:\Users\SSAFY\AppData\Roaming\marktext\images\2023-01-19-10-08-32-image.png)

<mark>-> 해석 a에 1개의값 넣고 나머지를 b에 넣어줘 라는 의미</mark>

- 묶여있는 리스트를 풀때도 `*리스트명` 하고 작성해주면 리스트가 풀리게 되고 안에 있는 값들이 튀어나옴

![](C:\Users\SSAFY\AppData\Roaming\marktext\images\2023-01-19-10-12-03-image.png)

<mark>-> 리스트로 묶인 my_list에 있는 10, 20, 30이</mark>

<mark>rlt = my_sum에서 풀려서 my_sum에 있는 함수를 만남</mark>

그래서 결과가 함수를 만난 결과가 나옴

#### - 함수를 정의할때 파라미터에 들어갈 알규먼트 값을 정의할때

- 포지셔널 알규먼트

- 키워드 알규먼트 

- 2개가 존재하는데 이때도 패킹을 이용하여 가변인자로 받을 수 있다.

#### - 가변 인자`(*args)`

> 

```python
def my_sum(*args):
    rlt = 0
    for value in args:
        rlt += value
    print(rlt)
```

이런식으로 받아서 작성이 가능하다.

키워드 알규먼트 역시 가변인자로 작성이 가능함

#### - 가변 키워드 인자`(**kwargs)`

> 

```python
def test(**kwargs):
    print(kwargs)
    return kwargs


test(name = 'swan', age = 24)
```

이런식으로 작성하면 test에 들어가는 키워드 값에 어떤걸 넣어줘도 전부 패킹해서 출력해줌

마찬가지로 포지셔널 + 키워드 둘다 동시에 사용 가능함

함수 정의부에서 `def(*args, **kwargs)` 이런 형식으로 작성하면

키워드가 아닌 것들은 전부 포지셔널 알규먼트에 들어가고 키워드에 해당하는건 전부 키워드 알규먼트로 들어간다.

### 패킹/언패킹 과 산술연산자의 구분

> 

- *(별표) 가 대입식의 좌측에 위치

- *(별표) 가 하나의 연산자에만 사용

- -> 패킹/언패킹으로 사용

- *(별표) 가 이항 연산자로 사용 되면 산술 연산자로써 곱셈을 의미한다.

## 모듈/패키지

- 파이썬 하나의 파일을 모듈이라 한다 (`test.py` 이런형식)

- 다양한 기능을 하나의 파일로 만든것을 모듈이라 함

- 다양한 파일을 하나의 폴더로 만든것을 패키지라 함

- 함수들의 집합 > 모듈 
  
  - 모듈의 집합 > 패키지 
    
    - 패키지의 집합 >> 라이브러리
      
      - 이것을 관리하는 관리자 >> pip

- import를 사용해서 모듈과 패키지를 불러옴

- from 파일이름 import 함수명 으로 작성

### - pip

- pypi 사이트에 자동으로 접근해서 설치함

- 설치
  
  - pip install SomePackage
  
  - pip install SomePackage == 1.0.5
  
  - pip install SomePackage >= 1.0.4

- 삭제
  
  - pip uninstall SomePackage

- 패키지 관리하기

- 아래의 명령어들을 통해 패키지 목록을 관리[1] 하고 설치[2] 할수 있음

- 일반적으로 패키지를 기록하는 파일의 이름은 requirements.txt로 정의함
1. pip freeze > requirements.txt

2. pip install -r requirments.txt



## 가상환경

- 파이썬 표준 라이브러리가 아닌 외부 패키지와 모듈을 사용하는 경우 모두 pip를 통해 설치 해야 함

- 복수의 프로젝트를 하는 경우 버전이 상이할 수 있음

- 이러한 경우 가상환경을 만들어 프로젝트별로 독립적인 패키지를 관리 할 수 있음

- 가상 환경을 만들고 관리하는데 사용되는 모듈

- 특정 디렉토리에 가상 환경을 만들고, 고유한 파이썬 패키지 집합을 가질 수 있음
  
  - 특정 폴더에 가상 환경이 있고
  
  - 실행 환경(ex-bash)에서 가상환경을 활성화 시켜
  
  - 해당 폴더에 있는 패키지를 관리/사용함

### 가상환경 만들기

1. git이 없는 폴더에서 git-bash 실행

2. (1. python) (2. -m) (3. venv) (4. venv)

 -> (1.파이썬아) (2. 모듈을 쓸건데) (3. venv라는 가상환경)을 실행할건데 (4. 폴더이름은 venv)로 해줘

3. 가상환경 실행 > source (venv : 폴더명)/Scripts/activate >> source로 venv 폴더에 있는 스크립트에 있는 activate를 실행

4. 가상환경 끄기 > deactivate



### 작업환경이 달라질때 가상환경 가져오는법

1. 작업중인 가상환경을 키고

2. pip freeze > requirements.txt 로 실행

3. 바뀐 작업환경에서 가상환경을 키고

4. pip install -r requirements.txt


